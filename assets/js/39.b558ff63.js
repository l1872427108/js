(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{437:function(t,a,e){"use strict";e.r(a);var r=e(56),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"object和map区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object和map区别"}},[t._v("#")]),t._v(" Object和Map区别")]),t._v(" "),e("ol",[e("li",[t._v("意外的键\nMap默认不包含任意的健，只包含显示插入的键。")])]),t._v(" "),e("p",[t._v("Object有一个原型原型，原型上的键名可以和对象上设置的发生冲突。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("键的类型\nMap 可以是任意类型的值，包含函数、对象。")])]),t._v(" "),e("p",[t._v("Object 键必须是 String 或 Symbol。")]),t._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[t._v("键的顺序\nMap 中的 key 是有序的，当迭代的时候，Map对象以插入的顺序返回。")])]),t._v(" "),e("p",[t._v("Object 的键是无序的。")]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[t._v("Size\nMap 可以通过 size 属性获取。")])]),t._v(" "),e("p",[t._v("Object 的键只能手动计算。")]),t._v(" "),e("ol",{attrs:{start:"5"}},[e("li",[t._v("迭代\nMap 是 iterable 的，可以直接被迭代。")])]),t._v(" "),e("p",[t._v("Object 需要以某种方式获取健名才能迭代。")]),t._v(" "),e("ol",{attrs:{start:"6"}},[e("li",[t._v("性能\nMap 在频繁增删的场景下表示很好。")])]),t._v(" "),e("p",[t._v("Object在频繁删除键值的场景下未做优化。")])])}),[],!1,null,null,null);a.default=s.exports}}]);